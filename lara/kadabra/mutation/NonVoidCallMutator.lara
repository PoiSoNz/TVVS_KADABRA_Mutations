import lara.mutation.Mutator;
import kadabra.KadabraNodes;

/**
 *  @param {$joinpoint} $joinpoint - Joinpoint used as starting point to search for non void method calls which will be replaced by a hardcoded value.
 *  Method call mutations:
 *  - If method type is primitive or boxed BOOLEAN, method call is replaced by false.
 *  - If method type is primitive INT, BYTE, SHORT OR LONG, method call is replaced by 0.
 *  - If method type is primitive FLOAT or DOUBLE, method call is replaced by 0.0.
 *  - If method type is primitive CHAR, method call is replaced by '\u0000'.
 *  - If method type is non of the above, method call is replaced by null.
 */

var NonVoidCallMutator = function($joinpoint) {
	// Parent constructor
    Mutator.call(this);

	// Instance variables
	this.toMutate = [];
	this.currentIndex = 0;
	
	this.originalCallNode = undefined;
	this.$callNode = undefined;
	
	// Checks
	var extraArgs = arrayFromArgs(arguments, 1);
	if(extraArgs.length != 0)
		throw "Expected only 1 argument but received " + (this.extraArgs.length + 1);

	this.extractMutationTargets($joinpoint);
};


// Inheritance
NonVoidCallMutator.prototype = Object.create(Mutator.prototype);


/*** IMPLEMENTATION OF INSTANCE METHODS ***/

// Analyze method calls available for Non Void Call mutation and store them
NonVoidCallMutator.prototype.extractMutationTargets = function($joinpoint) {

	// Map method call type to the respective mutation value (if a type is not on the list, it's mapped to 'null' value)
	var typeToValue = { 
		'boolean': 'false',
		'Boolean': 'false',
		'int': '0',
		'byte': '0',
		'short': '0',
		'long': '0',
		'float': '0.0',
		'double': '0.0',
		'char': '\u0000',
		'String': '\u0000'
	};
	var typeList = Object.keys(typeToValue);

	for($call of WeaverJps.searchFrom($joinpoint, 'call').get()) {
		if(this.hasValidAscendant($call) && $call.returnType !== 'void') {
			// Store call for later modification
			var mutationValue = typeList.includes($call.returnType) ? typeToValue[$call.returnType] : 'null';
			this.toMutate.push([$call, mutationValue]);
		}
	}
}

/**
 *  Returns true if a $call is acceptable for mutation
 *  A calls is acceptable if it's descendant of at least one of the following:
 *  - assignment, localVariable, if, loop
 */
NonVoidCallMutator.prototype.hasValidAscendant = function($call) {
	var validAncestors = ['assignment', 'localVariable', 'if', 'loop'];
	//Para caso espicifico de ifs e loops, ver se ÃƒÂ© descendente do primeiro filho do if (que ÃƒÂ© a condiÃƒÂ§ÃƒÂ£o)
	for(validAncestor of validAncestors) {
		// If $call.ancestor method is undefined, it's because such an ancestor does not exist
		var ancestor = $call.ancestor(validAncestor);
		if(typeof ancestor !== 'undefined')
			return true;
	}
	
	return false;
}

NonVoidCallMutator.prototype.hasMutations = function() {
	return this.currentIndex < this.toMutate.length;
}


NonVoidCallMutator.prototype._mutatePrivate = function() {
	var mutationInfo = this.toMutate[this.currentIndex++];

	this.$callNode = mutationInfo[0];
	var mutationValue = mutationInfo[1];

	this.originalCallNode = this.$callNode.copy();

	/* Char and String mutation value is a null character, which generates a null node when using it directly with insertReplace.
	   A KadabraNodes.literal is required to solve the problem */
	if(this.$callNode.returnType === 'char' || this.$callNode.returnType === 'String') {
		var mutatedNode = KadabraNodes.literal(mutationValue, this.$callNode.returnType);
		this.$callNode = this.$callNode.insertReplace(mutatedNode);
	} else {
		this.$callNode = this.$callNode.insertReplace(mutationValue);
	}
}

NonVoidCallMutator.prototype._restorePrivate = function() {
	this.$callNode = this.$callNode.insertReplace(this.originalCallNode.srcCode);

	this.originalCallNode = undefined;
	this.$callNode = undefined;
}