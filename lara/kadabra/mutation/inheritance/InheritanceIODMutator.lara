import lara.mutation.Mutator;

/**
 *  @param {$binaryExpression} $binaryExpression - A join point of type binaryExpression.
 *  @param {String[] | String...} newOperators - Operators that will be used to mutate the given binaryExpression.
 */
var InheritanceIODMutator = function(method) {
	// Parent constructor
   	Mutator.call(this);

	// Instance variables
	this.method = method;
	this.mutationsArgs = arrayFromArgs(arguments, 1);
	this.originalMethod = method.copy();
	this.mutated = false;
	this.overTagIndex = -1;

	var valid = false;
	for(var i = 0; i < this.method.children.length; i++) {
		if(this.method.children[i].instanceOf('expression') && this.method.children[i].type === 'Override') {
			valid = true;
			this.overTagIndex = i;
			break;
		}
	}
	if(!valid)
		throw "InheritanceIODMutator expects overriden method";	

};

// Inheritance
InheritanceIODMutator.prototype = Object.create(Mutator.prototype);


/*** IMPLEMENTATION OF INSTANCE METHODS ***/

InheritanceIODMutator.prototype.hasMutations = function() {
	return !this.mutated;
}


InheritanceIODMutator.prototype._mutatePrivate = function() {
	println("mutate");

	println(this.overTagIndex);

	println(this.method.ast);

	var methodCopy = this.method.copy();
	println(methodCopy.children);
	methodCopy.children.splice(this.overTagIndex, 1);
	println(methodCopy.children);
	
	this.method = this.method.insertReplace(methodCopy.srcCode);
	this.mutated = true;

	println(this.method.ast);
}

InheritanceIODMutator.prototype._restorePrivate = function() {
	// Restore operator
	this.method = this.method.insertReplace(this.originalMethod);
	this.originalMethod = undefined;
}
