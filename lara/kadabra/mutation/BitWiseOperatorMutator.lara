import lara.mutation.Mutator;

/**
 *  @param {$binaryExpression} $binaryExpression - A join point of type binaryExpression.
 *  @param {String[] | String...} newOperators - Operators that will be used to mutate the given binaryExpression.
 */
var BitWiseOperatorMutator = function($bitwiseOperator) {
	// Parent constructor
    Mutator.call(this);

	// Instance variables
	this.$bitwiseOperator = $bitwiseOperator;
	this.newOperators = arrayFromArgs(arguments, 1);
	this.currentIndex = 0;
	this.originalExpression = undefined;

	var unaryOperators = ["~", ""];
	var binaryOperators = ["|", "&", "^", "lhs", "rhs"];

	var validMutations = [];
	
	// Checks
	if(this.newOperators.length == 0)
		throw "Expected mutations but received none";


	// Check it is a bitwise operator
	if($bitwiseOperator.instanceOf('binaryExpression') && binaryOperators.contains($bitwiseOperator.operator)) {
		this.validMutations = Object.assign([], binaryOperators);
	}
	else if($bitwiseOperator.instanceOf('unaryExpression') && unaryOperators.contains($bitwiseOperator.operator)) {
		this.validMutations = Object.assign([], unaryOperators);	
	}
	else {
		throw "Expected a bitwise operator, received a " + $bitwiseOperator.operator;
	}

	
	var index = this.validMutations.indexOf($bitwiseOperator.operator);
	this.validMutations.splice(index, 1);
	
	
	for(var i = 0; i < this.newOperators.length; i++) {
		if(!this.validMutations.contains(this.newOperators[i])) {
			var appendMessage = "";
			var invalidOperator = this.newOperators[i] === "" ? "\"\"" : this.newOperators[i];
			if($bitwiseOperator.instanceOf('unaryExpression'))
				appendMessage = ", expected \"\"";
			else
				appendMessage = ", expected at least one of " + this.validMutations.toString();
			
			throw "Received invalid mutation " + invalidOperator + appendMessage;
		}
	}

};

// Inheritance
BitWiseOperatorMutator.prototype = Object.create(Mutator.prototype);


/*** IMPLEMENTATION OF INSTANCE METHODS ***/

BitWiseOperatorMutator.prototype.hasMutations = function() {
	return this.currentIndex < this.newOperators.length;
}


BitWiseOperatorMutator.prototype._mutatePrivate = function() {
	// Obtain new operator, increment index
	var newOp = this.newOperators[this.currentIndex];
	this.currentIndex++;

	this.originalExpression = this.$bitwiseOperator.copy();

	// Set new operator
	if(newOp === "")
		this.unaryMutate();
	else
		this.binaryMutate(newOp);
}

BitWiseOperatorMutator.prototype._restorePrivate = function() {
	// Restore operator
	this.$bitwiseOperator = this.$bitwiseOperator.insertReplace(this.originalExpression);
	this.originalExpression = undefined;
}

BitWiseOperatorMutator.prototype.unaryMutate = function() {
	var toReplace = this.$bitwiseOperator.operand.copy();
	this.$bitwiseOperator = this.$bitwiseOperator.insertReplace(toReplace);
}

BitWiseOperatorMutator.prototype.binaryMutate = function(newOp) {
	if(newOp === "lhs") {
		var lhs = this.$bitwiseOperator.lhs.copy();
		this.$bitwiseOperator = this.$bitwiseOperator.insertReplace(lhs);
	}
	else if(newOp === "rhs") {
		var rhs = this.$bitwiseOperator.rhs.copy();
		this.$bitwiseOperator = this.$bitwiseOperator.insertReplace(rhs);
	}
	else
		this.$bitwiseOperator.operator = newOp;
}
